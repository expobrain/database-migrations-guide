{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This is a collection of migration guides for different databases.</p> <p>Currently the list of documented database is very short and includes:</p> <ul> <li>PostgreSQL</li> </ul>"},{"location":"#contribute","title":"Contribute","text":"<p>If you want to contribute you can do it in different forms:</p> <ul> <li>fork the repository and make a pull request</li> <li>create an issue describing te problem or request</li> </ul> <p>In both cases you are more than welcome to share your experience and feedback!</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>This is a fork of the initial work made by QasimK.</p>"},{"location":"postgres/","title":"Index","text":"<p>Migration guides for PostgreSQL.</p>"},{"location":"postgres/how_tos/","title":"How tos","text":""},{"location":"postgres/how_tos/#how-can-the-access-exclusive-lock-break-applications","title":"How can the ACCESS EXCLUSIVE lock break applications?","text":"<p>An <code>ACCESS EXCLUSIVE</code> lock conflicts with everything, including:</p> <ul> <li><code>SELECT</code></li> <li><code>INSERT</code></li> <li><code>UPDATE</code></li> <li><code>DELETE</code></li> </ul> <p>If a transaction is used, all rows will be locked until the transaction is committed.</p> <p>Warning</p> <p>A migration needing this lock will block other queries as soon as the SQL is sent to Postgres (even while waiting for a lock). See How can the lock queue break applications?</p>"},{"location":"postgres/how_tos/#how-can-the-lock-queue-break-applications","title":"How can the lock queue break applications?","text":"<p>A migration can block application queries even while it is waiting for its turn to execute.</p> <ol> <li>Migration SQL is sent to Postgres</li> <li>It cannot execute right now because it needs to obtain a lock</li> <li>The migration enters the lock queue</li> <li>Now, the application executes another query that needs a lock that would conflict with the migration's lock.</li> <li>The application query enters the lock queue behind the migration SQL.</li> <li>The application query is blocked on the migration SQL which is blocked on some other application query.</li> </ol> <p>So even though the application query could execute because the migration is not executing, Postgres will not do this!</p> <p>So even if the migration would execute instantly if only it had the lock, it doesn't matter. It starts to block other conflicting queries immediately.</p> <p>This could mean the application has temporarily degraded performance, and worse, if the migration is taking too long, actual queries and requests will start to fail until the migration has completed.</p> <p>Therefore, you should use a <code>statement_timeout</code> that is about a second long.</p> <pre><code>SET statement_timeout = 1000;\n</code></pre> <p>Note</p> <p>Note that a <code>lock_timeout</code> is a subset of a <code>statement_timeout</code>, but queries are blocked while in the lock queue and while the migration is executing therefore a <code>statement_timeout</code> is the appropriate timeout to use.</p> <p>Since this is likely to timeout for busy tables, an automatic retry script should be used. See How to obtain a lock safely for a migration.</p>"},{"location":"postgres/how_tos/#how-can-applications-block-migrations","title":"How can applications block migrations?","text":"<p>Lock queue.</p> <p>Migration can never obtain a lock because it uses a <code>lock_timeout</code> because it must never break applications.</p> <p>When a query or migration requires a lock, it will enter the lock queue.</p> <p>Any locks that conflict with a lock in the queue will have to wait for its turn.</p> <p>This means application queries can be blocked by migrations.</p> <p>It also means that migrations can be blocked by application queries.</p> <p>Therefore, applications should keep queries and transactions short.</p> <p>Try to break transactions into smaller chunks that are less than a minute long, and add a sleep time in between these chunks.</p> <p>This will give a chance for a migration to obtain a lock before its <code>lock_timeout</code> expires.</p> <p>Of course, it is likely that a migration will need to be retried using a bash script.</p> <p>A migration should use a short <code>lock_timeout</code> and a slightly longer <code>statement_timeout</code> when it is retrying.</p> <p>This is so that the application does not become degraded.</p> <p>There are usually two parts to a server application: the client-facing application such as an API, and background services/jobs such as crons or message processors.</p> <p>The client-facing part usually naturally has short queries and transactions. However, background tasks can have long-running transactions and queries that can block migrations.</p>"},{"location":"postgres/how_tos/#write-applications-to-not-block-migrations","title":"Write applications to not block migrations","text":"<p>he application needs to give migrations a chance to obtain a lock.</p> <p>So structure application queries and transactions so that there is opportunity for other processes to obtain a lock.</p> <p>Actions:</p> <ol> <li>All transactions should be as short as possible, ideally less than minute long.</li> <li>Split up long-running transactions into smaller chunks. Consider using a separate staging table for the job.</li> <li>In between these smaller transactions, sleep for a few seconds to give other processes a chance to get a lock on the table.</li> <li>Even with this, for extremely busy tables, it will be necessary to be able to temporarily shut down background jobs leaving only the absolutely necessary parts of the application running.</li> <li>Background tasks should be written to handle immediate termination, and there should be a mechanism to immediately or gracefully stop these tasks.</li> </ol>"},{"location":"postgres/how_tos/#how-to-obtain-a-lock-safely-for-a-migration","title":"How to obtain a lock safely for a migration","text":"<p>Execute a migration that obtains a dangerous lock without blocking application queries.</p> <p>So execute the migration using a script to automatically retry, and use a short <code>lock_timeout</code> with a sleep time to minimise the impact on the application.</p> <p>The retry script:</p> <pre><code>#!/bin/bash\nwhile true; do\n    date\n    psql -qX -v ON_ERROR_STOP=1 -f migration.sql &amp;&amp; echo \"done\" &amp;&amp; break\n    sleep 1\ndone\n</code></pre> <p>Example <code>migration.sql</code> file:</p> <pre><code>SET lock_timeout = 100;\nSET statement_timeout = 1000;\n\nALTER TABLE table ADD COLUMN column INT DEFAULT 0;\n</code></pre> <p>Every one second queries will be blocked for 100 milliseconds, except when the migration has got its lock, then queries could be blocked for 1000 milliseconds.</p>"},{"location":"postgres/how_tos/#how-can-the-for-update-lock-break-applications","title":"How can the FOR UPDATE lock break applications?","text":"<p>From the perspective of an application, the row-level <code>FOR UPDATE</code> lock will block some writes to the table, e.g.:</p> <ul> <li><code>UPDATE</code></li> <li><code>SELECT FOR UPDATE</code></li> <li><code>DELETE</code></li> </ul> <p>This lock only blocks the selected rows, rather than the whole table. However, <code>UPDATE table SET column = value;</code> will effectively lock the entire table.</p> <p>If a transaction is used, the rows will be locked until the transaction is committed.</p> <p>Therefore it's important to reduce the number of rows blocked, and to reduce the amount of time those rows are blocked, in order to prevent the application from being blocked with its update operations.</p>"},{"location":"postgres/how_tos/#can-the-row-exclusive-lock-break-applications","title":"Can the ROW EXCLUSIVE lock break applications?","text":"<p>Technically, a table-level <code>ROW EXCLUSIVE</code> is obtained as well as this is an UPDATE. However, this doesn't conflict with the kind of queries that applications do including other <code>UPDATE</code> SQL.</p> <p>On the other hand, it can conflict with other migrations, so make sure you only do one migration at a time and this includes data migrations.</p>"},{"location":"postgres/how_tos/#what-are-the-disadvantages-of-a-not-null-check-constraint","title":"What are the disadvantages of a NOT NULL check constraint","text":"<ul> <li>People may not realise the column is<code>NOT NULL</code> because the constraint belongs to the table rather than being an option on the column.</li> <li>Writes are slower (~0.5-1% hit)</li> <li>Managing a constraint may be more complicated with your ORM and migration framework(s).</li> </ul>"},{"location":"postgres/how_tos/#get-the-list-of-index-for-a-given-table","title":"Get the list of index for a given table","text":"<p>To get the list of all the indexes for a given table in PostgreSQL:</p> <pre><code>SELECT *\nFROM pg_indexes\nWHERE tablename = 'my-table'\n</code></pre>"},{"location":"postgres/add/columns/","title":"Columns","text":"<p>Info</p> <p>List fo how-tos related to tese operations:</p> <ul> <li>How can the ACCESS EXCLUSIVE lock break applications?</li> <li>How can the lock queue break applications?</li> <li>How can applications block migrations?</li> <li>HOW-TO: Write applications to not block migrations</li> <li>How to obtain a lock safely for a migration</li> </ul>"},{"location":"postgres/add/columns/#nullable","title":"Nullable","text":""},{"location":"postgres/add/columns/#with-a-default","title":"With a default","text":"<p>It is unsafe to add a new column:</p> <pre><code>ALTER TABLE table ADD COLUMN column INT DEFAULT 0;\n</code></pre> <p>All queries of every kind will be blocked until the migration is complete because an <code>ACCESS EXCLUSIVE</code> lock is required.</p> <p>However, if the application is written with this in mind and migration timeouts are used, then it is possible to eventually do this safely.</p> <p>See the How to obtain a lock safely for a migration section below for a step-by-step guide on what to do.</p>"},{"location":"postgres/add/columns/#without-a-default","title":"Without a default","text":"<p>It is unsafe to add a new column:</p> <pre><code>ALTER TABLE table ADD COLUMN column INT;\n</code></pre> <p>All queries of every kind will be blocked until the migration is complete because an <code>ACCESS EXCLUSIVE</code> lock is required.</p> <p>However, if the application is written with this in mind and migration timeouts are used, then it is possible to eventually do this safely.</p> <p>See the How to obtain a lock safely for a migration section below for a step-by-step guide on what to do.</p> <p>Warning</p> <p><code>NULL</code> columns cannot be made into <code>NOT NULL</code> columns safely after-the-fact until Postgres 12. So if you are actually intending to make a <code>NOT NULL</code> column, then create a <code>NOT NULL</code> column with a dummy default value.</p>"},{"location":"postgres/add/columns/#not-nullable","title":"Not nullable","text":"<p>Bug</p> <p>Incomplete - add safe alternative.</p>"},{"location":"postgres/add/constraints/","title":"Constraints","text":"<p>Bug</p> <p>Incomplete - add constraint.</p>"},{"location":"postgres/add/foreign_keys/","title":"Foreign keys","text":"<p>Bug</p> <p>Incomplete - add foreign key.</p>"},{"location":"postgres/add/indexes/","title":"Indexes","text":""},{"location":"postgres/add/indexes/#unsafe-alternative","title":"Unsafe alternative","text":"<p>Creating an index is unsafe:</p> <pre><code>CREATE INDEX my_index ON my_table (my_column)\n</code></pre> <p>Creating an index acquire a write lock on the table and needs a full scan, this means that for the whole duration of the index creation any read operation will be allowed but write operations will be waiting for the lock to be released.</p>"},{"location":"postgres/add/indexes/#safe-alternative","title":"Safe alternative","text":"<p>A safe alternative for write-centric high traffic tables is to create an index concurrently:</p> <pre><code>CREATE INDEX CONCURRENTLY my_index ON my_table (my_column)\n</code></pre> <p>A concurrent index is an index created in background by PostgresSQL which doesn't interfere with the normal operation of the table.</p> <p>The index is created in more than one step and the whole process is described in the Building Indexes Concurrently document.</p> <p>Creating an index concurrently has two major drawbacks:</p> <ol> <li>the DDL cannot be performed in a transaction, because of the nature of the process itself; this means that the operation is not atomic and to roll back you need to perform a DROP INDEX IF EXISTS</li> <li>consider indempotent index creation in your database migrations, because the concurrent creation of an index is not an atomic operation if it fails will leave an invalid index in the database; this means that in your database migrations must consider this case and i.e. use DROP INDEX IF EXISTS before creating the new index concurrently:</li> </ol> <pre><code>DROP INDEX IF EXISTS my_index;\nCREATE INDEX CONCURRENTLY my_index ON my_table (my_column);\n</code></pre>"},{"location":"postgres/alter/data/","title":"Data","text":"<p>Info</p> <p>List fo how-tos related to tese operations:</p> <ul> <li>How can the FOR UPDATE lock break applications?</li> <li>Can the ROW EXCLUSIVE lock break applications?</li> </ul>"},{"location":"postgres/alter/data/#unsafe-alternative","title":"Unsafe alternative","text":"<p>The following kinds of data migrations are unsafe</p> <pre><code>UPDATE table SET column = value;\nUPDATE table SET column = value WHERE condition;\n</code></pre> <p>Where many rows are updated, this will take a long time to complete, and, as a FOR UPDATE lock is obtained on the selected rows, writes to those rows will be blocked until the migration is complete.</p>"},{"location":"postgres/alter/data/#safe-alternative","title":"Safe alternative","text":"<p>Modify the data in batches that take about a second each to execute. This will reduce the amount of time the lock is held.</p> <p>Execute the script in a persistent shell:</p> <pre><code>#!/bin/bash\nset -e\nfor i in {0..100}; do\n    echo \"=== === === Batch#{i}\"\n    psql -v ON_ERROR_STOP=1 -v v1=\"${i}\" -f migration.sql\ndone\n</code></pre> <p><code>migration.sql</code> file:</p> <pre><code>SET statement_timeout = 2000;\n\nbegin;\n\\timing on\n\nUPDATE table\nSET column = value\nWHERE\n    id &gt;= (:v1 + 0) _ 1000\nAND id &lt; (:v1 + 1) _ 1000\n;\n\ncommit;\n</code></pre> <p>In this example, we use the primary key of the table to chunk the rows into batches of 1000, and the start and stop range <code>0..100</code> was determined manually. Also, the transaction is useless, but it may be necessary for more complex migrations. Furthermore, we enable timing so that we have insight on how long each update takes. Finally, it is trivial to stop/resume by altering the start of the range.</p>"},{"location":"postgres/alter/table/","title":"Table","text":""},{"location":"postgres/alter/table/#rename-a-table","title":"Rename a table","text":"<p>Error</p> <p>UNSAFE - NEVER DO THAT</p>"},{"location":"postgres/alter/table/#rename-a-column","title":"Rename a column","text":"<p>A rename must be treated as adding a column, then backfilling data, then removing a column, which means it has the pitfalls of all three, along with the problem of synchronising writes to the old and new columns.</p>"},{"location":"postgres/alter/table/#safe-alternative","title":"Safe alternative","text":"<ol> <li>Add the new column.</li> <li>Synchronise writes to both columns.</li> <li>Backfill data to the new column.</li> <li>Read and write to the new column in the application.</li> <li>Remove the old column and any remaining synchronisation.</li> </ol> <p>This remaining part of this section will detail the synchronisation process only. Other sections of this guide (by following the flow chart again) detail how to do each of the other above steps safely.</p> <p>There are three possible strategies for synchronising writes to both columns:</p> <ol> <li>Use database-level triggers to synchronise the new column with the old column and vica versa.</li> <li>Use ORM framework-level synchronisation to synchronise the fields across the whole application automatically.</li> <li>Not recommended Use application-level synchronisation, where the fields are manually synchronised in code at each line the fields are modified.</li> </ol> <p>Note</p> <p>This section is incomplete and does not tell you how to do each strategy yet.</p>"},{"location":"postgres/alter/table/#make-a-column-not-nullable","title":"Make a column not nullable","text":"<p>Info</p> <p>List fo how-tos related to tese operations:</p> <ul> <li>How can the ACCESS EXCLUSIVE lock break applications?</li> <li>How can the lock queue break applications?</li> <li>How to obtain a lock safely for a migration</li> <li>What are the disadvantages of a NOT NULL check constraint?</li> </ul>"},{"location":"postgres/alter/table/#unsafe-alternative","title":"Unsafe alternative","text":"<p>It is unsafe to make a column <code>NOT NULL</code>:</p> <pre><code>ALTER TABLE table COLUMN column SET NOT NULL;\n</code></pre> <p>Tip</p> <p>Until Postgres 12</p> <p>All queries of every kind will be blocked until the migration is complete because an <code>ACCESS EXCLUSIVE</code> lock is required. Since a full table scan is required to validate the constraint, this could take a long time for large tables.</p>"},{"location":"postgres/alter/table/#safe-alternative_1","title":"Safe alternative","text":"<p>Create a <code>NOT NULL</code> check constraint instead.</p> <pre><code>ALTER TABLE table ADD CONSTRAINT constraint CHECK (column IS NOT NULL) NOT VALID;\nALTER TABLE table VALIDATE CONSTRAINT constraint;\n</code></pre> <p>In order to do this safely, please see Add &gt; Constraint.</p> <p>That's it... Until Postgres 12 where this check constraint can be converted into a proper NOT NULL constraint.</p>"},{"location":"postgres/drop/data/","title":"Data","text":""},{"location":"postgres/drop/data/#unsafe-alternative","title":"Unsafe alternative","text":"<p>Deleting all data in a table using TRUNCATE is unsafe because it needs an ACCESS EXCLUSIVE lock:</p> <pre><code>TRUNCATE TABLE my_table\n</code></pre> <p>Also TRUNCATE is not MVCC-safe.</p>"},{"location":"postgres/drop/data/#safe-alternative","title":"Safe alternative","text":"<p>Use DELETE to delete data from a table.</p>"},{"location":"postgres/drop/tables/","title":"Tables","text":""},{"location":"postgres/drop/tables/#unsafe-alternative","title":"Unsafe alternative","text":"<p>Dropping a table is unsafe if the table has foreign keys to other tables:</p> <pre><code>DROP TABLE my_table;\n</code></pre> <p>When dropping a table for each foreign key the database must check if there are any row in the referenced table that will violate the constraint.</p> <p>This can take a lot of time depending if the referenced table is optimised for querying or not (i.e. don't have an index) also will require an <code>ACCESS EXCLUSIVE</code> lock on the referenced table.</p>"},{"location":"postgres/drop/tables/#safe-alternative","title":"Safe alternative","text":"<p>To safely drop the table it's better first drop each foreign key one by one using the technique describe in How to obtain a lock safely for a migration and then drop the table as last operation.</p>"}]}